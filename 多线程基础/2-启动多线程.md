---
title: 2-启动多线程
tags:
  - 多线程基础
categories:
  - 多线程基础
description: >-
  一次线程两次调用start（）方法会发生什么情况？既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢?
cover: 'https://image.imxyu.cn/file/startThread.png'
abbrlink: 9a18081a
date: 2021-12-11 21:21:58
---
## 启动线程的正确方法

通过代码来看一下start和run方法，这里通过Lambda的方式来建一个Runnable接口，就像我们上节所说的，这个接口可以被我们重复利用，而不用重新new一个Thread类降低消耗

![image-20211212145249153](https://image.imxyu.cn/file/image-20211212145249153.png)

我们可以看到使用run() 并没有创建新的线程，还是在当前主线程中进行执行的，不是我们的本意

**得出结论**：

正确的方法就是使用start() 方法创建线程

## start方法含义

start方法的含义：

* 启动**新线程**： 告诉我们的jvm我们要启动一个线程了（只是一个请求，并不是立马执行），而真正的执行顺序是交给我们的jvm决定的，因此我们有时按照顺序执行了两个线程的start（），可能第二个线程先执行。这个过程牵扯到了**两个线程**，首先需要一个执行创建线程的主线程(可能是Main)，然后才是我们创建的新线程。
* 准备工作，新出来的子线程会让自己处于一个就绪状态，还有各种jvm的准备工作，然后分配到相应的时间片才可以运行
* 不能重复的start（）

### 不能重复start()

下面我们来看看第三条

代码测试：

![image-20211212193232832](https://image.imxyu.cn/file/image-20211212193232832.png)

原因：

当一个线程开始执行后，线程的状态从就绪=》运行=》终止

当线程变成终止状态后就永远不会返回回去

start源码分析：

* 启动新线程检查线程状态
* 加入线程组
* 调用Start0()

![image-20211212193653691](https://image.imxyu.cn/file/image-20211212193653691.png)

![image-20211212193701163](https://image.imxyu.cn/file/image-20211212193701163.png)

当线程被创建后初始化status=0，每次启动前会进行检查，看是否是初始化的状态。当线程运行后这个状态就会改变，再次运行这里检查status就会抛出异常

## run方法

run()我们之前看过，就是简单的三行代码。

![image-20211212194102373](https://image.imxyu.cn/file/image-20211212194102373.png)

因此当我们直接执行run()就是普通的run方法，只有我们调用start（）方法才是真正启动一个线程的方法，它会帮我们间接的调用run方法

## 本节面试问题总结

一次线程两次调用start（）方法会发生什么情况？为什么？

既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢?

答案看文档







